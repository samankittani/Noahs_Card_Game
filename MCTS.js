let GLOBAL_ITER = 0; /* global count of the current iteration, used throughout tree to calculate UCB*/

const ACTIONS = { /* all possible actions */
  endTurn: 'eTurn',
  buy: 'buy',
  playBlack: 'pClub',
  playRed: 'pSpade',
}
const SUITS = { /* all possible 'suits' */
  spade: 'spade',
  club: 'club',
  diamond: 'diamond',
  heart: 'heart'
  }
const ROLLOUTTYPES = {/* rollout types, s* = must simulate to end*/
  sBiasRand: 'biasRand',
  smaxPointDiff: 'maxPointDiff',
  pointDiff: 'pointDiff'
};
Object.freeze(ACTIONS);
Object.freeze(SUITS);
/*  
card Class used in the MCTS. 
Only used for data. 
Cannot have methods.
Must be JSON.stringify compatible for easy copying*/
class cardClass{
  constructor(number, suit, cost, wPoints){
    this.number = number;
    this.suit = suit;
    this.cost = cost;
    this.wPoints = wPoints;
  }
}
/*
state class used to keep track of the state in the current node.
Similar to cardClass, it must remain JSON stringify compatible */
class stateClass{
  constructor(human, oppD, myD, shopD, shopFD, shop, myHand, oppHand, myDis, oppDis){
    this.human = human;
    this.oppD = oppD;
    this.myD = myD;
    this.shopD = shopD;
    this.shopFD = shopFD;
    this.shop = shop;
    this.myHand = myHand;
    this.oppHand = oppHand;
    this.myDis = myDis;
    this.oppDis = oppDis;
  }
}
/*
  Sort all decks and hands, 
  Generated by Google Bard.
  stateClass is DeepCopied, so this must be decoupled from the state
  Thanks Bard! */
  sortState = function (obj) {
    for (const key in obj) {
      if (Array.isArray(obj[key])) {
        obj[key].sort((a, b) => {
          if (a.number === b.number) {
            return a.suit.localeCompare(b.suit); // Sort suits alphabetically if numbers are the same
          }
          return a.number - b.number; // Sort by number first
        });
      }
    }
    return obj;
  }
  /*
  Bard contribution, uniformly sample between min and max */
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

/* 
one action and its respective data from a given node.
parameters:
  action:     one of the possible action in ACTIONS
  shopIndex:  used only if action is to buy. Specifies which card to buy
  nPicks:     the number of times this action was picked for expansion
  nWins:      the number of times this action lead to a win. 
              This value is the expectation of all of the nodes that this action can lead to
  winRatio:   expected nWins / nPicks
  UCB:        winRatio + sqrt(ln(root.i)/nPicks)
  node:     the node that the action is taken from. node holds state
  paths:      the possible outcomes of taking this action. 
  pathsLimit: the maximum number of paths that can be added to paths. Once full
              the action will randomly select from the */
class actionClass {
  constructor(option, shopIndex, node){
    this.action = option;
    this.shopIndex = shopIndex;
    this.UCB = Infinity;
    this.maxWiden = Infinity;
    this.nPicks = 0;
    this.ExpNWins = 0;
    this.winRatio;

    this.node = node;
    this.paths = new Array();
  };
  /* 
  taking this action leads to paths.length number of possibilities.
  update nWins, nPick, and UCB. It is the expection of the paths.*/
  updateUtility = function () {
    this.nPicks++;
    this.ExpNWins = 0;
    for (let i = 0; i < this.paths.length; i++) {
      let pathProb =  this.paths[i].nPicks/this.nPicks;
      this.ExpNWins += (this.paths[i].nWins * pathProb);
    };
    this.winRatio = this.ExpNWins / this.nPicks;
    this.UCB = this.winRatio + this.node.exploreParam * Math.sqrt(Math.log(GLOBAL_ITER)/this.nPicks);
    this.maxWiden = this.node.widenParam[0] * (this.nPicks ** this.widenParam[1]);  
    
  };
  /*
  Either generate a new state, or sample from path.
  Use the widenParam from node to decide what to do*/
  getNextNode(){
    if(this.paths.length < this.maxWiden){
      let nextState = this.generateNextState();
      let i = this.pathIndex(nextState);
      if(i !== -1){ /* in paths */
        return this.paths[i];
      }else{ /* not in paths, create new path */
        let newNode = new MCTNodeClass(nextState, this.node.exploreParam, this.node.widenParam, this);
        this.paths.push(newNode);
      }
    /* must sample from existing paths */
    }else{
      let randInt = getRandomInt(0, this.paths.length - 1);
      for(let i = 0; i < this.paths.length; i++){
        if(randInt < this.paths[i].nPicks){
          return this.paths[i];
        }
        randInt - this.paths[i].nPicks;
      }
    }

    return node;
  };
  /*
  create copy of parent state, perform action on state.
  return new state*/
  generateNextState = function () {
    let nextState = JSON.parse(JSON.stringify(this.node.state));

    nextState = this.performAction(nextState);
    nextState = this.refreshHand(nextState);
    nextState = this.swapActivePlayer(nextState);
    nextState = sortState(nextState);
    return nextState;
  };
  /* 
  Swap the active player out.
  switch all player based state properties */
  swapActivePlayer = function(nextState){
    const flippedState = {
      human: !nextState.human,
      oppD: nextState.myD,
      myD: nextState.oppD,
      shopD: nextState.shopD,
      shopFD: nextState.shopFD,
      shop: nextState.shop,
      myHand: nextState.oppHand,
      oppHand: nextState.myHand,
      myDis: nextState.oppDis,
      oppDis: nextState.myDis,
    };
    return flippedState;
  }
  /* 
  attempt to refill hand of active player*/
  refreshHand = function (nextState) {
    while(nextState.myHand.length < 3){
      if(nextState.myD.length === 0){new Array();
        this.refreshDeck(nextState)
      };
      let rand = getRandomInt(0, nextState.myD.length - 1);
      nextState.myHand.push(nextState.myD.splice(rand, 1)[0]);
    }
    return nextState;
  };
  /* 
  set the respective deck to the discard
  set the discard to empty*/
  refreshDeck = function(nextState){
    nextState.myD = nextState.myDis;
    nextState.myDis = new Array();
  }
  /* 
  modify a state based on his action instances action attribute 
  take a state and return that state modified*/
  performAction = function (nextState) {
    if (this.action === ACTIONS.endTurn) { /* do nothing*/
    } 
    else if (this.action === ACTIONS.buy) { /* if we are buying, push the shop item into our discard */
      nextState.myDis.push(nextState.shop.splice(this.shopIndex, 1)[0]);
    } 
    else if (this.action === ACTIONS.playBlack) { 
      nextState = this.performBlackAction(nextState);
    }
    else if (this.action === ACTIONS.playRed) {
      let rand = getRandomInt(0, nextState.oppHand.length-1);
      nextState.myDis.push(nextState.oppHand.splice(rand, 1)[0]);
    }
    return nextState;
  };
  /*
  delete a random card from the opponent
  delete one of our lowest value cards*/
  performBlackAction = function (nextState) {
  
    let rand = getRandomInt(0, nextState.oppHand.length-1);
    nextState.oppHand.splice(rand, 1);
  
    let best = 0;
    for (let i = 0; i < nextState.myHand.length; i++) {
      if (nextState.myHand[i].cost < nextState.myHand[best].cost) {
        best = i;
      }
    }
    nextState.myHand.splice(best, 1);
    return nextState;
  }
  /* 
  check if state is one of the paths available in this action*/
  pathIndex = function (state){
    for(let i = 0; i < this.paths.length; i++){
      if(_.isEqual(state, this.paths[i].state)){
        return i
      }
    }
    return -1;
  }
}


class MCTNodeClass{
  constructor(state, exploreParam, widenParam, parentAction = null){
    this.state = JSON.parse(JSON.stringify(state));
    this.actions = new Array();
    this.aveWinRatio;
    this.nPicks = 0;
    this.nWins = 0;

    this.parentAction = parentAction;

    /* Meta data to pass to actions unused in the node
       this data is used by the actions for UCB and selection behavior*/
    this.exploreParam = exploreParam;
    this.widenParam = widenParam;

    this.updateActions();
    this.state = sortState(this.state);
  }
  /*
  take the state given
  populate all possible actions for node*/
  updateActions = function() {
    this.actions.push(new actionClass(ACTIONS.endTurn, -1, this));
    let sum = 0; 
    for(let i = 0; i < this.state.myHand.length; i++){
      sum += this.state.myHand[i].number;
      if(this.state.myHand[i].wPoints === 15 && this.state.myHand[i].suit === SUITS.club && this.actions.indexOf(ACTIONS.playBlack) === -1){
        this.actions.push(new actionClass(ACTIONS.playBlack, -1, this))
      }
      if(this.state.myHand[i].wPoints === 15 && this.state.myHand[i].suit === SUITS.spade && this.actions.indexOf(ACTIONS.playRed) === -1){
        this.actions.push(new actionClass(ACTIONS.playRed, -1, this))
      }
    } 
    for(let i = 0; i < this.state.shop.length; i++){
      if(this.state.shop[i].cost <= sum){
        this.actions.push(new actionClass(ACTIONS.buy, i, this))
      }
    }
  }
  /* 
  return the next action to explore for this snode*/
  getNextActionInd = function() {
    for(let i = 0; i < node.actions.length; i++){
      if(node.actions[i].UCB > node.actions[bestIndex].UCB){
        bestIndex = i;
      }
    }
  } 
  
  /* 
  return the best action to play for this snode*/
  getBestActionInd = function() {
    for(let i = 0; i < node.actions.length; i++){
      if(node.actions[i].winRatio > node.actions[bestIndex].winRatio){
        bestIndex = i;
      }
    }
  } 
}


/* 
overhead that manages the entire tree. 
  @widenParam: must be a two dimensional array
*/
class MCTSClass{
  constructor(iter, widenParam, exploreParam, rolloutType){
    this.maxIter = iter;
    this.widenParam = widenParam;
    this.exploreParam = exploreParam;
    this.root;
    this.init();
  }
  /* 
  Run MCTS. */
  run = function(){
    let leaf = this.getBestLeaf();
    let res = this.rollOut(leaf);
    this.backProp(res, leaf);
    this.updateAllUtil();
  }
  /*
  iteratively go down the tree
  if the node has never been visited before, 
  it is a leaf node and needs a rollout*/
  getBestLeaf = function(){
    let node = this.root;

    while(node.nPicks !== 0){
      let bestActionInd = node.getNextActionInd();
      node = node.actions[i].getNextNode();
    }
    return node;
  }
  /*
  randomly perform actions until an end state is reached
  Return the reward value, reward is different depending on
  the parent of the leaf node*/


  

  init = function(){
    // create initial state variables
    const [oppD, myD, myHand, oppHand] = this.initDeck();
    const [shopD, shopFD, initShop] = this.initShop();
    const [myDis, oppDis] = [new Array(), new Array()];
    // create initial state
    const initState = new stateClass(false, oppD, myD, shopD, shopFD, initShop, myHand, oppHand, myDis, oppDis);

    // create root node
    this.root = new MCTNodeClass(initState, this.widenParam, this.exploreParam)
  }

  initDeck = function(){
    const oppD = new Array();
    const myD = new Array();
    const myHand = new Array();
    const oppHand = new Array();

    for (let i = 1; i < 6; i++) {
      oppD.push(new cardClass(i, SUITS.spade, i, i));
      myD.push(new cardClass(i, SUITS.club, i, i));
    }

    oppD.push(new cardClass(0, SUITS.spade, 15, 15));
    myD.push(new cardClass(0, SUITS.club, 15, 15));

    // sample from deck and populate hand
    let randIndOp;
    let randIndMe;

    // while hand is not full, pop a random one from deck and push to hand
    while(myHand.length < 3){
      randIndMe = getRandomInt(0, myD.length-1);
      randIndOp = getRandomInt(0, oppD.length-1);
      myHand.push(myD.splice(randIndMe, 1)[0]);
      oppHand.push(oppD.splice(randIndOp, 1)[0]);
    }
    return [oppD, myD, myHand, oppHand];
  }

  initShop = function(){
    const shopD = new Array();
    const shopFD = new Array();
    const shop = new Array();
    
    for (let i = 6; i < 11; i++) {
      shopD.push(new cardClass(i, SUITS.spade, i, i));
      shopD.push(new cardClass(i, SUITS.club, i, i));
    }
    for (let i = 0; i < 2; i++) {
      shopFD.push(new cardClass(0, SUITS.spade, 15, 15));
      shopFD.push(new cardClass(0, SUITS.club, 15, 15));
    }

    // sample from deck and populate hand
    let randIndSh;

    // while hand is not 
    // full, pop a random one from deck and push to hand
    while(shop.length < 4 && shopD.length){
      randIndSh = getRandomInt(0, shopD.length - 1);
      shop.push(shopD.splice(randIndSh, 1)[0]);
    }

    if(shop.length){
      randIndSh = getRandomInt(0, shopFD.length - 1);
      shop.push(shopFD.splice(randIndSh, 1)[0]);
    }

    return [shopD, shopFD, shop];
  }

}

const MCTS = new MCTSClass(10000, [0.5, 1], 2);

// console.log(MCTS)

console.log(MCTS)

let test = JSON.parse(JSON.stringify(MCTS.root.state));






//console.log(_.isEqual(test, MCTS.root.state));

test.myDis.push(new cardClass(3,'club', 3, 3))

//console.log(_.isEqual(test, MCTS.root.state));

test.myDis.pop();

//console.log(_.isEqual(test, MCTS.root.state));

